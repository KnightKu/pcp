#!/software/python-2.7.3/bin/python
# Parallel cp program
# Copyright (c) Genome Research Ltd 2012
# Author Guy Coates <gmpc@sanger.ac.uk>
# This program is released under GNU Public License V2 (GPLv2)

__version__="0.9"

""" This program copies a directory tree in parallel.

Algorithm:

pcp implements a master-slave pattern. R0 is the master and R1...RX are the slaves.
R1 scan the source directory tree and put files to be copied on a queue on the master.
The master dispatches files in the queue to ranks R1..RX, which do the copy.

"""

import argparse
import os
import stat
import sys
import shutil
import traceback
import time
import ctypes
import lustre
from collections import deque

try:
    from mpi4py import MPI
except ImportError:
    print"""
ERROR: Your environment needs to be configured for MPI.
http://mediawiki.internal.sanger.ac.uk/wiki/index.php/How_to_run_MPI_jobs_on_the_farm
"""
    raise

# Ctypes boilerplate for readdir/opendir/closedir
clib=ctypes.CDLL("libc.so.6",use_errno=True)

class dirent(ctypes.Structure):
    _fields_ = [
        ("ino_t", ctypes.c_ulong),
        ("off_t", ctypes.c_ulong),
        ("d_reclen", ctypes.c_short),
        ("d_type",  ctypes.c_char ),
        ("d_name", ctypes.c_char * 4000)
]

class c_dir(ctypes.Structure):
    pass

dirent_p=ctypes.POINTER(dirent)
c_dir_p=ctypes.POINTER(c_dir)
opendir=clib.opendir
opendir.argtypes=[ctypes.c_char_p]
opendir.restype=c_dir_p
closedir=clib.closedir
closedir.argtypes=[c_dir_p]
closedir.restype=ctypes.c_int
readdir=clib.readdir
readdir.argtypes=[c_dir_p]
readdir.restype=dirent_p


def parseargs():
    parser=argparse.ArgumentParser(description="Copy a directory tree in parallel",formatter_class=argparse.RawDescriptionHelpFormatter,
                                   epilog="""

This program traverses a directory tree and copies files in the tree in
parallel. It does not copy individual files in parallel. It should be invoked
via mpirun.

Detailed information can be found here:

http://mediawiki.internal.sanger.ac.uk/wiki/index.php/Parallel_file_copies

If run with the -l flag, pcp will be lustre stripe aware. When it encounters
a striped file it will stripe the copy across all OSTs at the destination. Note
that it does not exactly preserve stripe information.

If a size is specified with -ls, pcp will not stripe files smaller than this,
even if the original is striped.

For maximum efficiency, ensure tasks are spread across as many different
machines as possible using ptile=1 to prevent local network bottlenecks. 

You should submit pcp jobs to the normal/long queues and not the parallel
queue; machines in the parallel queue have less network bandwidth available
than the main farm.

Example bsub:

bsub -R "span[ptile=1]" -oo logfile.txt -n 4  mpirun pcp ... """)
                                   
    parser.add_argument("SOURCE",help="source directory")
    parser.add_argument("DEST",help="destination directory")
    parser.add_argument("-d",help="dead worker timeout (seconds)",default=10,type=int)
    parser.add_argument("-n","--dry-run",help="perform a trial run with no copies made",action="store_true",default=False)
    parser.add_argument("-t",help="retry file copies N times in case of IO errors",type=int,metavar="N",default=1)
    parser.add_argument("-p",help="preserve ownership/permissions",default=False,action="store_true")
    parser.add_argument("-v",help="verbose",default=False,action="store_true")
    parser.add_argument("-V","--version",help="print version number",action='version',version=os.path.basename(sys.argv[0])+ " version "+__version__)
    parser.add_argument("-l",help="be lustre stripe aware",default=False,action="store_true")
    parser.add_argument("-ls",help="do not stripe files smaller than B bytes. Implies -l. Size can be suffixed with k,M,G,T,P",metavar="B",default=0)

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)
    args=parser.parse_args()

    if args.ls <> 0:
        args.l=True
        args.ls=SIConvert(args.ls)
        if args.ls==-1:
            print "Error: incorrect size specification."
            exit(1)
    return(args)


def Abort():
    MPI.COMM_WORLD.Abort(1)
    exit (1)


def sanitycheck(sourcedir,destdir):
    """Perform some sanity checks, including creating the destination directory if it does not exist and
    ensuring excessive parallelism is not used.
    """
    # holds the number of processes that each filesystem can support
    maxprocfs={"/nfs":5,
                  "/warehouse":5,
                  "/lustre":100}
    
    for path in sourcedir,destdir:
        fullpath=os.path.realpath(path)

        for filesystem in maxprocfs:
            if fullpath.startswith(filesystem) and workers >= maxprocfs[filesystem]:
                print
                print "ERROR: attempting to copy to a %s directory with more than %i tasks." %(filesystem,maxprocfs[filesystem])
                print "Please lower the amount of parallelism."
                print
                Abort()
    # if lustre option is set, check we are on a lustre filesystem.
    if LSTRIPE:
        try:
            layout=lustre.getstripe(sourcedir)
        except IOError,error:
            if error.errno==2:
                print "ERROR: %s is not a lustre directory but lustre stripe preservation is set." %sourcedir
                print "Exiting."
                Abort()
    #Create the top level destdir if it does not already exist
    robustCreateDir(sourcedir,destdir)

def scantree(sourcedir):
    """Scans sourcedir recursively and returns a list of files and a list of directories."""
    filelist=[]
    dirlist=[]

    print "R1: Scanning list of files to copy..."
    if not  os.path.isdir(sourcedir):
        print "R1: Error: %s not a directory" %sourcedir
        exit (1)
    startime=time.time()
    for entry in fastwalk(sourcedir):
        source,dirs,files=entry
        dirlist.extend([(os.path.join(source,d)) for d in dirs ])
        filelist.extend([(os.path.join(source,f)) for f in files])

    endtime=time.time()
    walltime=endtime-startime
    totalfiles=len(filelist)
    totaldirs=len(dirlist)
    rate=(totalfiles+totaldirs)/walltime
    print "R1: Scan Done. Did %i files, %i dirs in %i seconds" %(totalfiles,totaldirs,walltime)
    return(filelist,dirlist)

def fastwalk (sourcedir):
    """Improved version of os.walk: generates a tuple of (sourcedir,[dirs],[files]). This version
    tries to use readdir to avoid expensive stat operations on lustre."""

    filelist=[]
    dirlist=[]
    global WARNINGS
    dirp=opendir(sourcedir)
    if not bool(dirp):
        print "R1 WARNING: Cannot open %s:"  %(sourcedir),
        print os.strerror(ctypes.get_errno())
        WARNINGS+=1
    else:
        while True:
            p=readdir(dirp)
            if not p:
                break
            name=p.contents.d_name
            filetype=p.contents.d_type
            if not name in (".",".."):
                if filetype=="\x00":
                    # Filesystem does not support d_type, so we hae to do the stat.
                    fullname=os.path.join(sourcedir,name)
                    mode=os.lstat(fullname).st_mode
                    if stat.S_ISDIR(mode):
                        filetype="\x04"
                    else:
                        filetype="\x08"
                if filetype=="\x04":
                    dirlist.append(name)
                else:
                    filelist.append(name)
        closedir(dirp)

    yield (sourcedir,dirlist,filelist)
    for d in dirlist:
        fullname=os.path.join(sourcedir,d)
        for entries in fastwalk(fullname):
            yield entries

def ConsumeWork(sourcedir,destdir):
    """Take an item from the workqueue and copy it from sourcedir to destdir"""
    tasksdone=0
    bytescopied=0
    starttime=time.time()

    # Poll for work.
    while 1:
        message=comm.isend(("WAITING",rank),dest=0,tag=1)
        work=comm.recv(source=0,tag=1)
        message.Wait()
        if work==None:
            break

        for item in work:
            destination=mungePath(sourcedir,destdir,item)
            bytes,status=robustCopyFile(item,destination)
            if status == 0:
                bytescopied+=bytes
                tasksdone+=1


    endtime=time.time()
    elapsedtime=endtime-starttime
    # Return stats
    comm.gather((tasksdone,bytescopied,elapsedtime,WARNINGS),root=0)
    print "rank %i shutdown" %rank
    return(0)

def copyDirectories(sourcedir,destdir,dirlist):
    """Copy a list of directories (dirlist) from sourcedir to destdir"""
    for d in dirlist:
        destination=mungePath(sourcedir,destdir,d)
        robustCreateDir(d,destination)


def checkAlive(rank,workers,timeout):
    """Quirky farm nodes can cause the MPI runtime to lock up during the task spawn. This routine  
    checks whether nodes can exchange messages. If a node has not responded after timeout seconds we bail."""

    if rank > 0:
        comm.send(("ALIVE",rank),dest=0,tag=3)
            
    else:
        expectedworkers=set(range(1,workers))
        aliveworkers=set()
        giveuptime=time.time()+timeout
        while time.time() < giveuptime:
            if comm.Iprobe(source=MPI.ANY_SOURCE,tag=3):
                status,rank=comm.recv(source=MPI.ANY_SOURCE,tag=3)
                aliveworkers.add(rank)
                if len(aliveworkers)==len(expectedworkers):
                    print "R0: All workers have reported in."
                    return
        print "Error: The following workers did not report in after %i seconds" %timeout
        awol=expectedworkers.difference(aliveworkers)
        for i in awol:
            print "R%i" %i
        Abort()


def DispatchWork(filelist):
    """pop idle workers and the next workunit from the queue and dispatch them."""

    idleworkers=deque()
    while len(filelist) > 0:
        if comm.Iprobe(source=MPI.ANY_SOURCE,tag=1):
            status,data=comm.recv(source=MPI.ANY_SOURCE,tag=1)
            idleworkers.appendleft(data)

        # try for dispatch
        if len(idleworkers) > 0:
            worker=idleworkers.pop()
            OptimizeWorkUnitSize()
            # At the moment a workunit is 1 file.
            workunit=[filelist.pop()]
            comm.send(workunit,dest=worker,tag=1)

def OptimizeWorkUnitSize():
    """We can make small file copies more efficient by bunching them up into a single work request.
    """
    pass

def ShutdownWorkers(starttime):
    """Tell workers we have no more work for them and collate the stats"""
    totalwarnings=WARNINGS
    totalfiles=0
    totalbytes=0
    maxtime=0
    
    for r in range(1,workers):
        comm.send(None,dest=r,tag=1)
    data=comm.gather(0,root=0)

    # Gather the runtime statistics
    endtime=time.time()
    totalelapsedtime=endtime-starttime

    print ""
    print "Transfer Statisics:"
    print ""

    for r in range(1,workers):
        filescopied=data[r][0]
        bytescopied=data[r][1]
        elapsedtime=data[r][2]
        totalwarnings+=data[r][3]
        totalfiles+=filescopied
        totalbytes+=bytescopied
        print "Rank %i copied %s in %i files (%s/s)" %(r,prettyPrint(bytescopied),filescopied,prettyPrint(bytescopied/elapsedtime))
    print "Total data copied: %s in %i files (%s/s)" %(prettyPrint(totalbytes),totalfiles,prettyPrint(totalbytes/totalelapsedtime))
    print "Warnings %i" %totalwarnings


def createDir(sourcedir,destdir):
    """Create destdir, setting permissions and stripe attributes to be the same as  sourcedir"""
    global WARNINGS

    # Don't worry is the destination directory already exists
    try:
        os.mkdir(destdir)
    except OSError,error:
        if error.errno<>17:
            raise error
    if PRESERVE:
        try:
            stat=os.lstat(sourcedir)
            os.chmod(destdir,stat.st_mode)
            os.chown(destdir,stat.st_uid,stat.st_gid)
            # Don't worry if we can't set the permissions/uid to be the same as the
            # previous side; we might be copying someone else's data.
        except OSError,error:
            if error.errno<>1:
                raise error
            else:
                print "R%i WARNING: Unable to set permissions on %s" %(rank,destdir)
                WARNINGS+=1

    if LSTRIPE:
        layout=lustre.getstripe(sourcedir)
        if layout.isstriped():
            if VERBOSE:
                print "(striped)",
            lustre.setstripe(destdir,stripecount=-1)
        else:
            lustre.setstripe(destdir,stripecount=1)

def robustCreateDir(sourcedir,destdir):
    """Attempt to copy a directory. Retry the copy MAXTRIES in case of IO error."""
    global WARNINGS
    if DRYRUN:
        if VERBOSE:
            print "R%i mkdir %s" %(rank,destdir)
    else:
        i=0
        while i < MAXTRIES:
            if VERBOSE:
                print "R%i mkdir %s" %(rank,destdir)
            try:
                createDir(sourcedir,destdir)
                break
            except IOError,error:
                i+=1
                print "WARNING: mkdir error on %s attempt %i" %(destdir,i)
                WARNINGS+=1
                if i==MAXTRIES:
                    print "ERROR: Max number of retries on %s exceeded" %(sourcedir)
                    raise error
    return

def mungePath(src,dst,f):
    """Convert the sourcepath to the desinationpath"""
    suffix=f.partition(src)[2]
    dest=dst+suffix
    return(dest)

def copyFile (src,dst):
    """Copy a file from src to dst. The copy is lustre stripe aware.
    Returns bytes copied.
    """
    
    srcstat=os.lstat(src)
    mode=srcstat.st_mode
    size=srcstat.st_size
    global WARNINGS

    # regular files
    if stat.S_ISREG(mode):
        
        if LSTRIPE:
            layout=lustre.getstripe(src)
            if layout.isstriped():
                if size < MINSTRIPESIZE:
                    if VERBOSE:
                        print "(small file, ignoring striping)",
                    count=1
                else:
                    if VERBOSE:
                        print "(striped)",
                    count=-1
            else:
                count=1

            try:
                lustre.setstripe(dst,stripecount=count)
            except IOError,error:
                if error.errno==17:
                    # file exists; blow it away and try again...
                    os.remove(dst)
                    lustre.setstripe(dst,stripecount=count)
                else:
                    raise error
                
        if PRESERVE:
            shutil.copy2(src,dst)
            try:
                os.chown(dst,srcstat.st_uid,srcstat.st_gid)
            except OSError,error:
                if error.errno==1:
                    print "R%i WARNING: Unable to preserve permissions on %s" %(rank,dst)
                    WARNINGS+=1
                else:
                    raise error
        else:
            shutil.copyfile(src,dst)
        return(size)
            
    # symlinks
    if stat.S_ISLNK(mode):
        linkto=os.readlink(src)
        try:
            os.symlink(linkto,dst)
        except OSError,error:
            if error.errno==17:
                os.remove(dst)
                os.symlink(linkto,dst)
            else:
                raise error
        return(0)

    # special files
    filemode=stat.S_IFMT(mode)
    if filemode==0010000:
        filetype="FIFO"
    elif filemode==0020000:
        filetype="character device"
    elif filemode==0060000:
        filetype="block device"
    elif filemode==0140000:
        filetype="socket"
    else:
        filetype="unknown"
    print "R%i WARNING: unable to copy (%s)" %(rank,filetype),
    WARNINGS+=1
    return(0)

def robustCopyFile(sourcepath,destpath):
    """Copies a file from sourcedir to destdir.
    Returns (bytes copied,status). status=0 if the copy worked, or 1 if it failed.
    If it encounters and IO error (eg due to lustre
    eviction), it will retry the copy until MAXTRIES is exceeded."""
    global WARNINGS
    size=0
    status=0
    if DRYRUN:
        if VERBOSE:
            print "R%i: %s" %(rank,sourcepath)
    else:
        i=0
        while i < MAXTRIES:
            if VERBOSE:
                print "R%i: %s" %(rank,sourcepath),
            try:
                starttime=time.time()
                size=copyFile(sourcepath,destpath)
                endtime=time.time()
                if size==0:
                    speed=0
                else:
                    speed=size/(endtime-starttime)
                if VERBOSE:
                    print "%s (%s/s)" %(prettyPrint(size),prettyPrint(speed))
                break
            except IOError,error:
                # Permission denied errors are not fatal. We emit a warning and
                # carry on.
                if error.errno==13:
                    print "WARNING: permission denied on %s" %(sourcepath)
                    WARNINGS+=1
                    status=1
                    break
                else:
                    i+=1
                    print "WARNING: Error copying %s on attempt %i"  %(sourcepath,i)
                    WARNINGS+=1
                    if i==MAXTRIES:
                        print "ERROR: Max number of retries on %s exceeded" %(sourcepath)
                        status=1
                        raise error
    return(size,status)

def prettyPrint(bytes):
    """convert bytes to k/M/G/T etc"""
    abrevs= (
        (1<<50,"Pbytes"),
        (1<<40,"Tbytes"),
        (1<<30,"Gbytes"),
        (1<<20,"Mbytes"),
        (1<<10,"kbytes"),
        (1,"bytes")
        )

    for factor,suffix in abrevs:
        if bytes>=factor:
            break
    string="%.*f %s" %(2,bytes/float(factor),suffix)
    return (string)


def SIConvert(amount):
    """convert human readable size to bytes (eg 1k -> 1024). Returns -1 if the format is unknown."""

    table=dict(K=1,k=1,M=2,G=3,T=4,P=5)

    try:
        number=int(amount)
        return(number)
    except ValueError:
        pass

    try:
        number,suffix=amount[:-1],amount[-1]
        multi=table[suffix]
        number=int(number)
    except:
        return(-1)
    return(number*(1024**multi))


# Main program

args=parseargs() 
DRYRUN=args.dry_run  # Dry run
MAXTRIES=args.t      # number of retries on IO error
PRESERVE=args.p      # preserve permissions etc
LSTRIPE=args.l       # preserve lustre information
MINSTRIPESIZE=args.ls  # don't stripe for files smaller than this
WARNINGS=0 # number of warning
VERBOSE=args.v    # Should we be verbose
sourcedir=args.SOURCE.rstrip(os.path.sep) # source
destdir=args.DEST.rstrip(os.path.sep)  # destination
timeout=args.d # dead worker timeout

filelist=[] # list of files to copy
dirlist=[]  # list of directories to copy

# Init MPI
comm=MPI.COMM_WORLD
rank=comm.Get_rank()
workers=comm.size
try:
    if rank==0:    
        # master process
        if workers < 2:
            print "ERROR: Only %i processes running. Did you invoke me via mpirun?" %workers
            print "This program requires at least 2 processes to run correctly."
            exit(0)
        else:
            print "Starting %i processes." %workers
        if LSTRIPE:
            print "Will copy lustre stripe information."
            if MINSTRIPESIZE>0:
                print "Will not stripe files smaller than %s"  %prettyPrint(MINSTRIPESIZE)
        checkAlive(rank,workers,timeout)
        sanitycheck(sourcedir,destdir)
        starttime=time.time()
        filelist,dirlist=scantree(sourcedir)
        print "Copying directories..."
        copyDirectories(sourcedir,destdir,dirlist)
        print "Copying files..."
        DispatchWork(filelist)
        ShutdownWorkers(starttime)
        print "Master process done."
        exit(0)

    else:
        # file copy workers
        checkAlive(rank,workers,timeout)
        ConsumeWork(sourcedir,destdir)
        exit(0)

# We need to call MPI ABORT in our exception handler,
# otherwise the other MPI processes spin forever.
except Exception,err:
    print err
    print traceback.print_tb(sys.exc_info()[2])
    Abort()

